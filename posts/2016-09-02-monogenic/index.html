<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>The number of monogenic subsemigroups of the full transformation monoid - J. D. Mitchell</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="The number of monogenic subsemigroups of the full transformation monoid" />
<meta property="og:description" content="Mathematics In this post we show how to count the number of monogenic subsemigroups of the full transformation monoid up to isomorphism.
Throughout this post, we denote the natural numbers \(\{0, 1, \ldots\}\) by \({\mathbb{N}}\). The symmetric group and full transformation semigroup on \(\{1, \ldots, n\}\), \(n\in {\mathbb{N}}\), are denoted \(S_n\) and \(T_n\), respectively. A subsemigroup of a semigroup \(S\) is monogenic if it can be generated by a single element; monogenic subsemigroups of finite groups are just cyclic subgroups." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://james-d-mitchell.github.io/posts/2016-09-02-monogenic/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-19T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-05-25T15:05:21&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The number of monogenic subsemigroups of the full transformation monoid"/>
<meta name="twitter:description" content="Mathematics In this post we show how to count the number of monogenic subsemigroups of the full transformation monoid up to isomorphism.
Throughout this post, we denote the natural numbers \(\{0, 1, \ldots\}\) by \({\mathbb{N}}\). The symmetric group and full transformation semigroup on \(\{1, \ldots, n\}\), \(n\in {\mathbb{N}}\), are denoted \(S_n\) and \(T_n\), respectively. A subsemigroup of a semigroup \(S\) is monogenic if it can be generated by a single element; monogenic subsemigroups of finite groups are just cyclic subgroups."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen" href="https://james-d-mitchell.github.io/css/main.css" />
  

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://james-d-mitchell.github.io/">J. D. Mitchell</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/publ">Publications</a>
		
		<a href="/soft">Software</a>
		
		<a href="/posts">Posts</a>
		
	</nav>
</header>

<main>
    
	<article>
		<div class="title">
			<h1 class="title">The number of monogenic subsemigroups of the full transformation monoid</h1>
		

		<section class="body">
			<h2 id="mathematics">Mathematics</h2>
<!-- TODO: oeis links, numbers, code explanation, inverse semigroups -->
<!-- TODO intro re: Attila's email --> 
<p>In this post we show how to count the number of monogenic subsemigroups of the
full transformation monoid up to isomorphism.</p>
<p>Throughout this post, we denote the natural numbers \(\{0, 1,
\ldots\}\) by \({\mathbb{N}}\). The <em><strong>symmetric group</strong></em> and <em><strong>full
transformation semigroup</strong></em> on \(\{1, \ldots, n\}\), \(n\in {\mathbb{N}}\),
are denoted \(S_n\) and \(T_n\), respectively. A subsemigroup of a
semigroup \(S\) is <em><strong>monogenic</strong></em> if it can be generated by a single element;
monogenic subsemigroups of finite groups are just cyclic subgroups. Let
\(\mathbf{s},\mathbf{t}: {\mathbb{N}}{\longrightarrow}{\mathbb{N}}\) be
defined by</p>
<p>$$\begin{aligned}
\mathbf{s}(n) &amp; = \text{ the number of non-isomorphic cyclic subgroups of }
S_n\\<br>
\mathbf{t}(n) &amp; = \text{ the number of non-isomorphic monogenic subsemigroups
of } T_n.
\end{aligned}$$</p>
<p>Since cyclic groups are determined up to isomorphism by their size, it follows
that \(\mathbf{s}(n)\) is the number of distinct orders of elements in
\(S_n\). The purpose of this post is to prove the following result.</p>
<p><strong>Theorem 1.</strong> <em>Let \(n\in {\mathbb{N}}\). Then</em>
\(\mathbf{t}(n)=\mathbf{s}(1)+\cdots+\mathbf{s}(n)\).</p>
<p>A <em><strong>partition</strong></em> of \(n\in {\mathbb{N}}\) is a \(k\)-tuple
\((a_1, \ldots, a_k)\), where \(k \geq 0\), \(a_1\geq\cdots\geq
a_k\geq1\), and \(a_1 + \cdots + a_k = n\).
For instance, the partitions of \(5\) are:</p>
<p>$$1 + 1 + 1 + 1 + 1,\ 2 + 1 + 1 + 1,\ 2 + 2 + 1,\ 3 + 1 + 1,\ 3 + 2,\ 4 + 1,<br>
5.$$</p>
<p>There is a unique partition of \(0\), namely, the empty partition
\(\varnothing\). We use the standard conventions that an empty sum equals
\(0\) and an empty product equals \(1\); in particular,
\({\operatorname{lcm}}(\varnothing)=1\).</p>
<p>The order of a permutation \(f\in S_n\) is just the least common multiple
of the lengths of its cycles, and so \({\mathbf{s}}(n)\) is the size of
the set
\(\{\operatorname{lcm}(a_1, a_2, \ldots, a_k):a_1 + \cdots + a_k = n\}.\)</p>
<p>If \(M\) is a finite monoid and \(x\in M\), then the <em><strong>index</strong></em> and
<em><strong>period</strong></em> of \(x\) are the least values \(m \in {\mathbb{N}}\) and \(r
\in {\mathbb{N}}\setminus\{0\}\) such that \(x ^ {m + r} = x ^{m}\),
respectively. We define \(x ^ 0\) to be the identity element of \(M\) for
all \(x\in M\). Consequently, the only elements in \(M\) with index \(0\)
are in the group of units.</p>
<p><strong>Lemma 2.</strong> <em>Let \(S\) be a semigroup and let \(s, t\in
S\). Then \({\langle s\rangle}\) and \({\langle t\rangle}\) are isomorphic
if and only if the index and period of \(s\) equal those of \(t\)</em>.</p>
<p>A special case of Lemma 2 is when \(S = S_n\), where the
lemma asserts that \({\langle s\rangle}\) and \({\langle t\rangle}\) are
isomorphic if and only if \(|{\langle s\rangle}|= |{\langle t\rangle}|\), as
mentioned above.</p>
<p>Recall that a <em><strong>digraph</strong></em> \(\Gamma\) is a pair \((V, E)\) consisting of a
<em><strong>vertex set</strong></em> \(V\) and an <em><strong>edge set</strong></em> \(E \subseteq V\times V\). A
digraph is <em><strong>functional</strong></em> if for every \(u\in V\) there exists a unique \(v\in
V\) such that \((u, v) \in E\). Suppose that \(D_n\) denotes the set of
functional digraphs with vertex set \(\{1,\ldots,n\}\). It is
straightforward to verify that the function mapping \(f\) to the functional
digraph \(\Gamma_f\) with vertices \(V = \{1, \ldots, n\}\) and edges
\({\{(v, f(v)):v\in V\}}\) is a bijection.</p>
<p>The period of a transformation \(f\in T_n\) is equal to the least common
multiple of the lengths of the cycles in the digraph \(\Gamma_f\), and the
index of \(f\) is equal to the maximal number of edges in a path \((x_1,
x_2, \ldots, x_k)\) where \(x_k\) belongs to a cycle of \(\Gamma_f\) but
\(x_1, x_2, \ldots, x_{k - 1}\) do not. In particular, the index of \(f\in
T_n\) is between \(0\) and
\(n - 1\), inclusive.</p>
<p>If \(p \in S_m\) is any permutation, then there exists a transformation
\(f\in T_n\) such that the period of \(f\) equals the order of \(p\) and
the index of \(f\) is any value in \(k \in \{0, \ldots, n - m\}\); one
such transformation is</p>
<p>\[f(i) =
\begin{cases}
p(i)  &amp; \text{if } 1 \leq i \leq m    \\<br>
i - 1 &amp; \text{if } m + 1\leq i \leq k \\<br>
m     &amp; \text{if } i &gt; k.
\end{cases}
\]</p>
<p><em>Proof of Theorem 1.</em>
Let \(A\) be the set of pairs \((m, r)\) such that \(m\) and \(r\) are
the index and period of some transformation of degree \(n\) and let $$A_m =
{\{r\in{\mathbb{N}}\setminus\{0\}:(m,r)\in A\}}.$$ Then, by Lemma 2, \(|A| =
{\mathbf{t}}(n)\) and \(|A| = |A_0| + |A_1| + \cdots + |A_{n - 1}| =
{\mathbf{t}}(n)\). It therefore suffices to show that
\(|A_m|={\mathbf{s}}(n-m)\) for all \(m \in \{0, \ldots, n -
1\}\).</p>
<p>If \(m \in \{0, \ldots, n - 1\}\) and \(B_m\) is the set of orders of
elements in \(S_{n-m}\), then clearly \(|B_m| = {\mathbf{s}}(n - m)\) and it
suffices to show that \(A_m = B_m\).</p>
<p>If \(r \in B_m\), then we showed above that there exists a transformation
\(f\in T_n\) with index \(m\) and period \(r\) and so \(r \in A_m\).</p>
<p>Conversely, if \(r\in A_m\), then, by the definition of \(A_m\), there
exists \(f\in T_n\) with index \(m\) and period \(r\). Since the index of
\(f\) is \(m\), there are at most \(n - m\) points in any cycle of
\(f\), and so \(r\) is the order of a permutation in \(S_{n -m}\). In
other words, \(r\in B_m\). \(\blacksquare\)</p>
<h2 id="computing-the-values---first-attempt">Computing the values - first attempt</h2>
<p>Theorem 1 gives an explicit formula for the number $\mathbf{t}(n)$ of monogenic
subsemigroups of the full transformation monoid $T_n$ in terms of the numbers
$\mathbf{s}(k)$ of cyclic subgroups of the symmetric group $S_k$. In this
section we describe how to actually compute $\mathbf{s}(k)$, and hence how to
compute $\mathbf{t}(k)$.
As mentioned above,</p>
<p>\[
\mathbf{s}(k) = |\{\operatorname{lcm}(a_1, a_2, \ldots, a_l):a_1 + \cdots + a_l = k\}|.
\]</p>
<p>One approach to computing $\mathbf{s}(k)$ is more or less clear:</p>
<ul>
<li>generate all of the distinct partitions of $k$;</li>
<li>find the least common multiple (lcm) of the numbers in each partition;</li>
<li>count the number of distinct such lcms.</li>
</ul>
<p>Generating integer partitions is a classical problem; see <!--Knuth's AoCP Volume 4, under the 'Generating all partitions' section, page 2, Algorithm H?-->.
A succinct implementation from <a href="https://stackoverflow.com/questions/10035752/">https://stackoverflow.com/questions/10035752/</a>
in python is:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00a8c8">def</span> <span style="color:#75af00">partitions</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">,</span> <span style="color:#111">I</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span><span style="color:#111">):</span>
    <span style="color:#00a8c8">yield</span> <span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">,)</span>
    <span style="color:#00a8c8">for</span> <span style="color:#111">i</span> <span style="color:#f92672">in</span> <span style="color:#111">range</span><span style="color:#111">(</span><span style="color:#111">I</span><span style="color:#111">,</span> <span style="color:#111">n</span><span style="color:#f92672">//</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#111">):</span>
        <span style="color:#00a8c8">for</span> <span style="color:#111">p</span> <span style="color:#f92672">in</span> <span style="color:#111">partitions</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#f92672">-</span><span style="color:#111">i</span><span style="color:#111">,</span> <span style="color:#111">i</span><span style="color:#111">):</span>
            <span style="color:#00a8c8">yield</span> <span style="color:#111">(</span><span style="color:#111">i</span><span style="color:#111">,)</span> <span style="color:#f92672">+</span> <span style="color:#111">p</span>
<span style="color:#111">[</span><span style="color:#111">x</span> <span style="color:#00a8c8">for</span> <span style="color:#111">x</span> <span style="color:#f92672">in</span> <span style="color:#111">partitions</span><span style="color:#111">(</span><span style="color:#ae81ff">5</span><span style="color:#111">)]</span>
<span style="color:#75715e"># [(5,), (1, 4), (1, 1, 3), (1, 1, 1, 2), (1, 1, 1, 1, 1), (1, 2, 2), (2, 3)]</span></code></pre></div>
<p>If $a, b\in \mathbb{N}$, then:</p>
<p>$$
\operatorname{lcm}(a, b) = \frac{ab}{\gcd(a, b)}
$$</p>
<p>and so we can compute $\operatorname{lcm}(a, b)$ by first finding $\gcd(a, b)$
using the <a href="https://w.wiki/QDV">Euclidean algorithm</a>. One succinct
implementation in python is:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00a8c8">def</span> <span style="color:#75af00">gcd</span><span style="color:#111">(</span><span style="color:#111">a</span><span style="color:#111">,</span><span style="color:#111">b</span><span style="color:#111">):</span>
    <span style="color:#00a8c8">while</span> <span style="color:#111">b</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#111">:</span>
        <span style="color:#111">a</span><span style="color:#111">,</span> <span style="color:#111">b</span> <span style="color:#f92672">=</span> <span style="color:#111">b</span><span style="color:#111">,</span> <span style="color:#111">a</span> <span style="color:#f92672">%</span> <span style="color:#111">b</span>
    <span style="color:#00a8c8">return</span> <span style="color:#111">a</span>
<span style="color:#111">gcd</span><span style="color:#111">(</span><span style="color:#ae81ff">2</span><span style="color:#111">,</span> <span style="color:#ae81ff">3</span><span style="color:#111">)</span> <span style="color:#75715e"># 1</span></code></pre></div>
<p>Mostly, we want to compute the lcm of more than two numbers, which we can do
by remembering that $\operatorname{lcm}$ is associative, meaning that</p>
<p>$$
\operatorname{lcm}(a, b, c) = \operatorname{lcm}(\operatorname{lcm}(a, b), c) = \operatorname{lcm}(a, \operatorname{lcm}(b, c)).
$$</p>
<p>In python:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00a8c8">def</span> <span style="color:#75af00">lcm</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#111">):</span>
    <span style="color:#111">a</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span>
    <span style="color:#00a8c8">for</span> <span style="color:#111">b</span> <span style="color:#f92672">in</span> <span style="color:#111">x</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">:]:</span>
        <span style="color:#111">a</span> <span style="color:#f92672">=</span> <span style="color:#111">a</span> <span style="color:#f92672">*</span> <span style="color:#111">b</span> <span style="color:#f92672">//</span> <span style="color:#111">gcd</span><span style="color:#111">(</span><span style="color:#111">a</span><span style="color:#111">,</span> <span style="color:#111">b</span><span style="color:#111">)</span>
    <span style="color:#00a8c8">return</span> <span style="color:#111">a</span>
<span style="color:#111">lcm</span><span style="color:#111">((</span><span style="color:#ae81ff">2</span><span style="color:#111">,</span> <span style="color:#ae81ff">3</span><span style="color:#111">,</span> <span style="color:#ae81ff">3</span><span style="color:#111">,</span> <span style="color:#ae81ff">4</span><span style="color:#111">,</span> <span style="color:#ae81ff">5</span><span style="color:#111">))</span> <span style="color:#75715e"># 60</span></code></pre></div>
<p>Putting together the previous sections, the following python function can be
used to compute some values of $\mathbf{s}(n)$:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00a8c8">def</span> <span style="color:#75af00">number_of_cyclic_subgroups</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">):</span>
    <span style="color:#00a8c8">return</span> <span style="color:#111">len</span><span style="color:#111">(</span><span style="color:#111">set</span><span style="color:#111">(</span><span style="color:#111">lcm</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#111">)</span> <span style="color:#00a8c8">for</span> <span style="color:#111">x</span> <span style="color:#f92672">in</span> <span style="color:#111">partitions</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">)))</span>
<span style="color:#111">[</span><span style="color:#111">number_of_cyclic_subgroups</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">)</span> <span style="color:#00a8c8">for</span> <span style="color:#111">n</span> <span style="color:#f92672">in</span> <span style="color:#111">range</span><span style="color:#111">(</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#ae81ff">20</span><span style="color:#111">)]</span>
<span style="color:#75715e"># [1, 2, 3, 4, 6, 6, 9, 11, 14, 16, 20, 23, 27, 31, 35, 43, 47, 55, 61]</span></code></pre></div>
<p>Popping these numbers into the <a href="https://oeis.org/A009490">oeis</a> shows us
sequence number <a href="https://oeis.org/A009490">A009490</a> (and might give us some
more confidence that the code above is correct); see Table 1.</p>
<p>\begin{array}{l|lllllllllllll}
n &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 &amp; 17 &amp;
18 &amp; 19 \\\hline
\mathbf{s}(n) &amp; 1&amp; 2&amp; 3&amp; 4&amp; 6&amp; 6&amp; 9&amp; 11&amp; 14&amp; 16&amp; 20&amp; 23&amp; 27&amp; 31&amp; 35&amp; 43&amp; 47&amp; 55&amp; 61
\end{array}</p>
<center><b>Table 1.</b>
Some small values of $\mathbf{s}(n)$ the number of cyclic
subgroups of the symmetric group $S_n$ up to isomorphism.</center>
<p>By Theorem 1, the number $\mathbf{t}(n)$ of monogenic subsemigroups of the full
transformation monoid is $\mathbf{t}(n)=\mathbf{s}(1)+\cdots+\mathbf{s}(n)$. In
python:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00a8c8">def</span> <span style="color:#75af00">number_of_monogenic_subsemigroups</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">):</span>
    <span style="color:#00a8c8">return</span> <span style="color:#111">sum</span><span style="color:#111">(</span><span style="color:#111">number_of_cyclic_subgroups</span><span style="color:#111">(</span><span style="color:#111">m</span><span style="color:#111">)</span> <span style="color:#00a8c8">for</span> <span style="color:#111">m</span> <span style="color:#f92672">in</span> <span style="color:#111">range</span><span style="color:#111">(</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#111">n</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#111">))</span>
<span style="color:#111">[</span><span style="color:#111">number_of_monogenic_subsemigroups</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#111">)</span> <span style="color:#00a8c8">for</span> <span style="color:#111">n</span> <span style="color:#f92672">in</span> <span style="color:#111">range</span><span style="color:#111">(</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#ae81ff">20</span><span style="color:#111">)]</span>
<span style="color:#75715e"># [1, 3, 6, 10, 16, 22, 31, 42, 56, 72, 92, 115, 142, 173, 208, 251, 298, 353, 414]</span></code></pre></div>
<p>Putting this sequence into the <a href="https://oeis.org/search?q=1%2C+3%2C+6%2C+10%2C+16%2C+22%2C+31%2C+42%2C+56%2C+72%2C+92%2C+115%2C+142%2C+173%2C+208%2C+251%2C+298%2C+353%2C+414&amp;sort=&amp;language=&amp;go=Search">oeis</a> yields:</p>
<blockquote>
<p>Sorry, but the terms do not match anything in the table.</p>
</blockquote>
<p>So, it seems like we computed something new. The first 19 terms in the sequence
can be seen in Table 2.</p>
<p>\begin{array}{r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r}
n &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 &amp; 17 &amp;
18 &amp; 19 \\\hline
\mathbf{t}(n) &amp; 1 &amp; 3 &amp; 6 &amp; 10 &amp; 16 &amp; 22 &amp; 31 &amp; 42 &amp; 56 &amp; 72 &amp; 92 &amp; 115 &amp; 142 &amp; 173 &amp; 208 &amp; 251 &amp; 298 &amp; 353 &amp; 414
\end{array}</p>
<center><b>Table 2.</b>
Some small values of $\mathbf{t}(n)$ the number of monogenic
subsemigroups of the full transformation monoid $T_n$ up to isomorphism.</center>
<!--
## Computing the values - second attempt

The approach to computing the values of $\mathbf{t}(n)$ described in the
previous section works, but it has some limitations. In particular, if we try
to find the partitions of, say $100$, then this was already so slow that I got
fed up waiting for python to tell me the answer...

<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#111">In</span> <span style="color:#111">[</span><span style="color:#ae81ff">112</span><span style="color:#111">]:</span> <span style="color:#111">timeit</span> <span style="color:#111">[</span><span style="color:#111">x</span> <span style="color:#00a8c8">for</span> <span style="color:#111">x</span> <span style="color:#f92672">in</span> <span style="color:#111">partitions</span><span style="color:#111">(</span><span style="color:#ae81ff">60</span><span style="color:#111">)]</span>
<span style="color:#ae81ff">1.85</span> <span style="color:#111">s</span> <span style="color:#960050;background-color:#1e0010">±</span> <span style="color:#ae81ff">43.5</span> <span style="color:#111">ms</span> <span style="color:#111">per</span> <span style="color:#111">loop</span> <span style="color:#111">(</span><span style="color:#111">mean</span> <span style="color:#960050;background-color:#1e0010">±</span> <span style="color:#111">std</span><span style="color:#f92672">.</span> <span style="color:#111">dev</span><span style="color:#f92672">.</span> <span style="color:#111">of</span> <span style="color:#ae81ff">7</span> <span style="color:#111">runs</span><span style="color:#111">,</span> <span style="color:#ae81ff">1</span> <span style="color:#111">loop</span> <span style="color:#111">each</span><span style="color:#111">)</span></code></pre></div>

We could always work on optimising the function `partitions`, but that probably
wouldn't allow us to compute the number of monogenic subsemigroups of $T_{100}$
even if we optimised `partitions` to the absolute limit.  To see why consider:

<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#111">In</span> <span style="color:#111">[</span><span style="color:#ae81ff">117</span><span style="color:#111">]:</span> <span style="color:#111">time</span> <span style="color:#111">number_of_monogenic_subsemigroups</span><span style="color:#111">(</span><span style="color:#ae81ff">50</span><span style="color:#111">)</span>
<span style="color:#111">CPU</span> <span style="color:#111">times</span><span style="color:#111">:</span> <span style="color:#111">user</span> <span style="color:#ae81ff">7</span> <span style="color:#111">s</span><span style="color:#111">,</span> <span style="color:#111">sys</span><span style="color:#111">:</span> <span style="color:#ae81ff">11.6</span> <span style="color:#111">ms</span><span style="color:#111">,</span> <span style="color:#111">total</span><span style="color:#111">:</span> <span style="color:#ae81ff">7.01</span> <span style="color:#111">s</span>
<span style="color:#111">Wall</span> <span style="color:#111">time</span><span style="color:#111">:</span> <span style="color:#ae81ff">7.03</span> <span style="color:#111">s</span>
<span style="color:#111">Out</span><span style="color:#111">[</span><span style="color:#ae81ff">117</span><span style="color:#111">]:</span> <span style="color:#ae81ff">13060</span></code></pre></div>

There are $204226$ partitions of $50$ and so each $\operatorname{lcm}$
operation took approximately $34$&#181;s. If we use $34$&#181;s as a lower
bound for the time to compute the $\operatorname{lcm}$ each of $190\ 569\ 292$
partition of $100$, then a lower bound for the time to compute
$\mathbf{t}(100)$ is around 1 hour and 40 minutes.  We should expect that the
actual runtime would be higher than this, since roughly speaking 
partitions of $100$ either have more summands or have larger
summands than partitions of $50$ and so the mean time to compute the lcm of a
partition of $100$ ought to be higher than that for $50$. In any case, 1 hour
and 40 minutes is too long for me.

The value of $\mathbf{t}(50)$ ($13060$) compared to the number of partitions of
$50$ ($204226$) already indicates the way to improve matters.

**Lemma 3.** 
*The number of distinct least common multiples of a partition of
$n\in \mathbb{N}$ equals the number of distinct products of powers of primes
$p$ where $p \leq n$.*
-->

		</section>

		<div class="post-tags">
			
			
			
		</div>
	</article>
			<div class="meta"> Last modified: May 25, 2021</div>
		</div>
</main>
<footer>
<hr><a class="soc" href="https://github.com/james-d-mitchell" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2021  © J. D. Mitchell |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script>
      feather.replace()
</script>

</div>
    </body>
</html>
